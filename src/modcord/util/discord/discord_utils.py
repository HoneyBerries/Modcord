"""
Low-level Discord utility functions for Modcord.

This module provides stateless helpers for Discord-specific operations, including message deletion, DM sending, permission checks, and moderation actions. All logic here is designed for use by higher-level bot components and should not maintain state.
"""


import asyncio
import datetime
from typing import List, Union
import discord
from modcord.settings.guild_settings_manager import guild_settings_manager
from modcord.util.logger import get_logger
from modcord.datatypes.discord_datatypes import MessageID, GuildID
from modcord.util import image_utils

logger = get_logger("discord_utils")

# ==========================================
# Duration/constants and choices (moved here so discord_utils is self-contained)
# ==========================================

# Human-friendly label for a permanent duration
PERMANENT_DURATION = "Till the End of Time"

DURATIONS = {
    "60 secs": 1,
    "5 mins": 5,
    "10 mins": 10,
    "30 mins": 30,
    "1 hour": 60,
    "2 hours": 120,
    "1 day": 24 * 60,
    "1 week": 7 * 24 * 60,
    PERMANENT_DURATION: 0,
}

DURATION_CHOICES = list(DURATIONS.keys())

DELETE_MESSAGE_CHOICES = [
    discord.OptionChoice(name="Don't Delete Any", value=0),
    discord.OptionChoice(name="Previous Hour", value=60),
    discord.OptionChoice(name="Previous 6 Hours", value=6 * 60),
    discord.OptionChoice(name="Previous 12 Hours", value=12 * 60),
    discord.OptionChoice(name="Previous 24 Hours", value=24 * 60),
    discord.OptionChoice(name="Previous 3 Days", value=3 * 24 * 60),
    discord.OptionChoice(name="Previous 7 Days", value=7 * 24 * 60),
]


def bot_can_manage_messages(channel: discord.TextChannel, guild: discord.Guild) -> bool:
    """
    Determine if the bot has permission to read and manage messages in a given text channel.

    Args:
        channel (discord.TextChannel): The channel to check permissions for.
        guild (discord.Guild): The guild context to resolve the bot's member object.

    Returns:
        bool: True if the bot can read and manage messages, False otherwise.
    """
    me = getattr(guild, "me", None)
    if me is None:
        return True

    try:
        permissions = channel.permissions_for(me)
    except Exception:
        return False

    return permissions.read_messages and permissions.manage_messages


def iter_moderatable_channels(guild: discord.Guild):
    """
    Iterate over text channels in a guild where the bot can safely manage messages.

    Args:
        guild (discord.Guild): The guild whose channels are inspected.

    Yields:
        discord.TextChannel: Channels suitable for moderation actions.
    """
    for channel in getattr(guild, "text_channels", []):
        try:
            if bot_can_manage_messages(channel, guild):
                yield channel
        except Exception as exc:
            logger.debug("Skipping channel %s due to error: %s", getattr(channel, 'name', '<unknown>'), exc)


def extract_embed_text_from_message(embed: discord.Embed) -> List[str]:
        """
        Extract all text content from a Discord embed.
        
        Extracts text from embed description and all fields, combining field
        names and values into formatted strings.
        
        Args:
            embed (discord.Embed): The embed to extract text from.
        
        Returns:
            List[str]: List of text strings extracted from the embed.
        """
        texts = []
        if embed.description and isinstance(embed.description, str):
            texts.append(embed.description.strip())
        texts.extend(
            f"{field.name}: {field.value}".strip() if field.name else field.value.strip()
            for field in embed.fields
            if isinstance(field.value, str) and field.value.strip()
        )
        return texts



def is_ignored_author(author: Union[discord.User, discord.Member]) -> bool:
    """
    Check if an author should be ignored by moderation handlers (e.g., bots or non-members).

    Args:
        author (discord.User | discord.Member): The user or member to check.

    Returns:
        bool: True if the author is a bot or not a member, False otherwise.
    """
    return author.bot or not isinstance(author, discord.Member)


def should_process_message(
    message: discord.Message,
    *,
    check_guild: bool = True
) -> bool:
    """
    Determine if a message should be processed for moderation.
    
    Centralized filtering logic that checks:
    - Guild messages only (DMs are excluded)
    - Not from bots (including the bot itself)
    - Not from users who are not guild members
    - Has at least some text content
    - Ignores messages generated by slash commands (interactions)
    
    This function is used by both real-time message processing and history fetching
    to ensure consistent filtering rules across the application.
    
    Args:
        message (discord.Message): The Discord message to check.
        check_guild (bool): If True, reject messages not in a guild. Default True.
    
    Returns:
        bool: True if the message should be processed, False otherwise.
    """
    # Ignore DMs
    if check_guild and message.guild is None:
        return False
    
    # Ignore messages from bots or non-members
    if is_ignored_author(message.author):
        return False

    # Ignore messages generated by slash commands (interactions)
    # These messages have message.interaction set
    if getattr(message, "interaction_metadata", None) is not None:
        return False
    
    # Check if message has text content or image attachments
    has_text = bool((message.clean_content or "").strip())
    has_images = any(image_utils.is_image_attachment(att) for att in message.attachments)
    
    return has_text or has_images


def has_elevated_permissions(member: Union[discord.User, discord.Member]) -> bool:
    """
    Check if a member has moderator-level privileges (administrator, manage guild, or moderate members).

    Args:
        member (discord.User | discord.Member): The member to evaluate.

    Returns:
        bool: True if the member has elevated permissions, False otherwise.
    """

    if not isinstance(member, discord.Member):
        return False

    # Check computed permissions first (includes all roles)
    perms = member.guild_permissions
    if perms.administrator or perms.manage_guild or perms.moderate_members:
        return True

    # Check for elevated roles by name
    elevated_keywords = ("mod", "moderator", "admin", "staff", "owner")
    for role in member.roles:
        if role.is_default() or role.managed:
            continue
        role_name = role.name.lower()
        if any(keyword in role_name for keyword in elevated_keywords):
            return True
    
    return False


def get_potential_moderator_roles(guild: discord.Guild) -> list[discord.Role]:
    """
    Get a list of roles in the guild that are likely moderator roles.

    Args:
        guild (discord.Guild): The guild to search.

    Returns:
        list[discord.Role]: List of potential moderator roles.
    """
    elevated_keywords = ("mod", "moderator", "admin", "staff", "owner")
    potential_roles = []
    
    for role in guild.roles:
        if role.is_default() or role.managed:
            continue
        
        perms = role.permissions
        if perms.administrator or perms.manage_guild or perms.moderate_members:
            potential_roles.append(role)
            continue
        
        name = role.name.lower()
        if any(keyword in name for keyword in elevated_keywords):
            potential_roles.append(role)
    
    return potential_roles


def get_potential_review_channel(guild: discord.Guild) -> discord.TextChannel | None:
    """
    Find a suitable channel for moderation reviews based on name.

    Args:
        guild (discord.Guild): The guild to search.

    Returns:
        discord.TextChannel | None: The found channel or None.
    """
    keywords = ("moderator", "admin", "staff", "log", "review", "audit")
    
    for channel in guild.text_channels:
        name = channel.name.lower()
        # Check if name contains any keyword
        if any(k in name for k in keywords):
            # Verify bot can send messages there
            if channel.permissions_for(guild.me).send_messages:
                return channel
    return None


def has_review_permission(guild_id: GuildID, user: discord.Member) -> bool:
    """
    Check if a user has moderator permissions for review actions.
    
    Checks both manage_guild permission and configured moderator roles.
    
    Args:
        guild_id: ID of the guild to check permissions for
        user: Discord member to check permissions for
    
    Returns:
        bool: True if user has moderator permissions, False otherwise
    """
    
    # Check if user has manage guild permission
    if user.guild_permissions.manage_guild:
        return True
    
    # Check if user has any of the configured moderator roles
    settings = guild_settings_manager.get(guild_id)
    if settings and settings.moderator_role_ids:
        user_role_ids = {role.id for role in user.roles}
        if any(role_id in user_role_ids for role_id in settings.moderator_role_ids):
            return True
    
    return False


def format_duration(seconds: int) -> str:
    """
    Convert a duration in seconds to a human-readable string.

    Args:
        seconds (int): Duration in seconds.

    Returns:
        str: Human-readable duration string.
    """
    if seconds == 0:
        return PERMANENT_DURATION
    elif seconds < 60:
        return f"{seconds} secs"
    elif seconds < 3600:
        mins = seconds // 60
        return f"{mins} mins"
    elif seconds < 86400:
        hours = seconds // 3600
        return f"{hours} hour{'s' if hours != 1 else ''}"
    else:
        days = seconds // 86400
        return f"{days} day{'s' if days != 1 else ''}"


def parse_duration_to_minutes(human_readable_duration: str) -> int:
    """
    Convert a human-readable duration label to its value in minutes.

    Args:
        human_readable_duration (str): Duration label from DURATION_CHOICES.

    Returns:
        int: Duration in minutes, or 0 if not found.
    """
    return DURATIONS.get(human_readable_duration, 0)


async def delete_recent_messages(guild, member, seconds) -> int:
    """
    Delete recent messages from a member across all moderatable channels within a time window.

    Args:
        guild (discord.Guild): The guild to search for messages.
        member (discord.Member): The member whose messages are deleted.
        seconds (int): Time window in seconds to look back.

    Returns:
        int: Number of messages deleted.
    """
    if seconds <= 0:
        return 0

    window_start = datetime.datetime.now(datetime.timezone.utc) - datetime.timedelta(seconds=seconds)
    deleted_count = 0

    for channel in iter_moderatable_channels(guild):
        channel_name = channel.name if hasattr(channel, 'name') else str(channel.id)
        try:
            async for message in channel.history(after=window_start):
                if message.author.id == member.id and await delete_message(message):
                    deleted_count += 1
        except Exception as exc:
            logger.error(f"Error deleting messages in {channel}: {exc}")

    return deleted_count


async def delete_messages_background(ctx: discord.ApplicationContext, user: discord.Member, delete_message_minutes: int):
    """
    Delete a user's messages in the background and notify the command invoker of the result.

    Args:
        ctx (discord.ApplicationContext): The command context for follow-up messaging.
        user (discord.Member): The member whose messages are deleted.
        delete_message_minutes (int): Time window in minutes to look back.
    """
    try:
        seconds = delete_message_minutes * 60
        deleted = await delete_recent_messages(ctx.guild, user, seconds)
        if deleted:
            await ctx.followup.send(f"ðŸ—‘ï¸ Deleted {deleted} recent messages from {user.mention}.", ephemeral=True)
        else:
            await ctx.followup.send(f"No recent messages found to delete from {user.mention}.", ephemeral=True)
    except Exception as e:
        logger.error(f"Error deleting messages in background: {e}")
        await ctx.followup.send("âš ï¸ Action completed, but failed to delete some messages.", ephemeral=True)


async def delete_message(message: discord.Message) -> bool:
    """
    Attempt to delete a Discord message, suppressing recoverable errors.

    Args:
        message (discord.Message): The message to delete.

    Returns:
        bool: True if deletion succeeded, False otherwise.
    """
    try:
        await message.delete()
        return True
    except discord.NotFound:
        return False
    except discord.Forbidden:
        logger.warning(f"No permission to delete message {message.id}")
    except Exception as exc:
        logger.error(f"Error deleting message {message.id}: {exc}")
    return False


async def delete_messages_by_ids(guild: discord.Guild, message_ids: list[MessageID] | MessageID) -> int:
    """
    Delete specific messages by their IDs across all moderatable channels in a guild, in parallel.

    Args:
        guild (discord.Guild): The guild to search for messages.
        message_ids (list[MessageID] | MessageID): List of message IDs or a single message ID.

    Returns:
        int: Number of messages deleted.
    """
    # Normalize input to a list
    if isinstance(message_ids, (str, int)):
        ids = [int(message_ids)]
    elif isinstance(message_ids, list):
        ids = [int(mid) for mid in message_ids if isinstance(mid, (str, int))]
    else:
        return 0

    if not ids:
        return 0

    deleted_count = 0
    pending_ids = set(ids)
    channels = list(iter_moderatable_channels(guild))

    async def fetch_and_delete(msg_id):
        for channel in channels:
            try:
                msg = await channel.fetch_message(msg_id)
                if await delete_message(msg):
                    return True
            except discord.NotFound:
                continue
            except Exception as exc:
                logger.error(f"Error deleting message {msg_id} in channel {getattr(channel, 'name', channel.id)}: {exc}")
                continue
        logger.debug(f"Failed to locate message: {msg_id}")
        return False

    # Run all fetch_and_delete tasks concurrently
    results = await asyncio.gather(*(fetch_and_delete(msg_id) for msg_id in pending_ids))
    deleted_count = sum(results)
    return deleted_count



def has_permissions(application_context: discord.ApplicationContext, **required_permissions) -> bool:
    """
    Check if the command issuer has all specified permissions in the guild.

    Args:
        application_context (discord.ApplicationContext): The command context.
        **required_permissions: Permission flags to check.

    Returns:
        bool: True if all permissions are present, False otherwise.
    """
    if not isinstance(application_context.author, discord.Member):
        return False
    return all(getattr(application_context.author.guild_permissions, permission_name, False) for permission_name in required_permissions)